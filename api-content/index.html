{"posts":[{"title":"nps-socks5服务一键搭建脚本","content":"基于nps的Shell脚本，集成socks5搭建，管理，启动，添加账号等基本操作。方便用户操作，并且支持快速构建socks5服务环境。 默认管理页面ip:18080 默认管理员账号密码:admin admin 默认socks5账号信息:账号socks5 密码socks5 端口5555 支持多端口、多账号管理 加密传输、数据压缩 服务端、客户端分离安装、可实现国内中专代理，降低被和谐概率 方法1：一键安装 wget -q -N --no-check-certificate https://raw.githubusercontent.com/wyx176/nps-socks5/master/install.sh &amp;&amp; chmod 777 install.sh &amp;&amp; bash install.sh 方法2：linux、windows均支持，需要安装go语言环境进行编译 参考【https://ehang-io.github.io/nps/#/install】 1、安装源码 go get -u github.com/wyx176/nps-socks5 2、编译服务端：进入到nps-socks5文件夹中执行命令 go build cmd/nps/nps.go 3、编译客户端：进入到nps-socks5文件夹中执行命令 go build cmd/npc/npc.go 相关文件路径、命令 1、后台管理的配置文件 /etc/nps/conf 登录账号web_username=admin 登录密码web_password=admin web管理端口web_port = 18080 修改后需要重启服务端 2、基本命令 启动服务端： nps start 停止服务端： nps stop 更新日志 2022.10.06 v3.0 1、端口增加创建时间、到期时间 2、开启用户注册 安装后修改/etc/nps/conf/nps.conf中 allow_user_login=true allow_user_register=true -2022.10.03 v2.0 1、增加多端口、多账号设置 -2022.09.03 v1.0 参考： https://github.com/wyx176/nps-socks5 https://t.me/Socks55555 ","link":"https://thxit.github.io/tA64nKq94/"},{"title":"al杂文6-11","content":"人民日报：“当身边的一道道风景，变成了回忆，才忽然发现，风景依然在，人已非少年。起初，我们揣着糊涂装明白；后来，我们揣着明白装糊涂。” 在这个世界的一隅，时间如同一位沉默的雕刻家，用它那无形却锋利的刻刀，在每个人的生命画卷上细细雕琢。岁月的河流悠悠向前，沿途携带着无数风景，有的如晨曦初照般清新，有的似黄昏落幕时深沉。它们在我们的生活中来了又去，最终沉淀在心底，成为一段段珍贵的记忆。 记得年少时，我们总爱用好奇的目光打量周围的一切，每一处风景都充满了探索的意义。那时候，天空更加蔚蓝，风也似乎更加温柔，就连夏日里最寻常的一片绿叶，也能在我们心中激起无限的遐想。我们在那些风景中奔跑、嬉戏，以为那就是世界的全部，以为自己会永远年轻，永远对未知充满渴望。 然而，时光荏苒，当那些曾经熟悉的景象逐渐变成远方的风景，只能在梦回时分轻轻触摸，我们才恍然醒悟，原来人生就是一场不断前行的旅程。那些曾经揣着糊涂装明白的日子，我们试图用简单的逻辑去理解这个复杂的世界，以为穿上大人鞋就能走进他们的世界，殊不知，那份纯真的糊涂，才是最值得怀念的宝藏。那时的我们，心怀梦想，勇敢无畏，即便面对不解和困惑，也能笑得灿烂如花。 而今，步入人生的另一个阶段，我们开始揣着明白装糊涂。这份明白，是历经风雨后的坦然，是看透世事的淡泊。我们明白了生活不仅仅有诗和远方，还有眼前的苟且；明白了不是所有的付出都会有回报，也不是所有的问题都有答案。于是，我们学会了适时的沉默，选择在某些时刻放下那份执念，不再强求每一个结果，更愿意享受过程中的每一份体验和感受。这并非是对生活的妥协，而是另一种形式的智慧与坚强。 风景依旧，四季轮回，而我们已不再是当初那个无忧无虑的少年。那些年一起追逐过的风，一同仰望过的星空，早已化作心中温柔的印记。每当夜深人静之时，这些回忆如同老电影一般，在脑海中缓缓播放，提醒着我们曾经拥有过的美好与纯真。或许，正是这些变化与成长，让我们更加珍惜眼前的一切，学会在忙碌与浮躁中寻找心灵的宁静，于平凡中体味不凡。 最终，我们会发现，无论是揣着糊涂装明白的青涩，还是揣着明白装糊涂的成熟，都是生命不可或缺的一部分。它们像两面镜子，映照出我们成长的轨迹，见证着每一次蜕变与升华。在这场旅行中，风景可以常新，人心亦能常宽，只要我们不忘初心，保持那份对生活的热爱与向往，便能在未来的日子里，继续以一颗纯净而坚韧的心，拥抱每一个明天。 于是，当身边的一道道风景，再次映入眼帘，我们不再是那个只知奔跑的少年，而是学会了慢下脚步，用心去感受，去珍惜。因为深知，风景依旧在，人虽非少年，但那份对美好事物的追求与热爱，永远不会改变。 ","link":"https://thxit.github.io/qx3PvbFHm/"},{"title":"centos服务器出售vps闲置流量","content":"https://www.cnblogs.com/yuxl94/p/17747677.html https://hub.docker.com/r/traffmonetizer/cli_v2 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo docker run -i --name tm traffmonetizer/cli_v2 start accept --token eHbtKUBqK14uQ0ahY5TnWNTeBomV/0GQosbOz2EVKJI= ","link":"https://thxit.github.io/9Eh-e8kZL/"},{"title":"从君主论学习领导的艺术","content":"我们在现实中总是充当一个被管理者的角色，比如作为学生是被教育，作为员工是被管理，然而，如果真正想有一番作为的人，都会认识到管理团队的重要性。团队的能量有多大，决定你干成的事业有多大。 从古至今，身为帝王君主，就不能不学习领导的艺术，学的好那就是开疆拓土青史留名，这方面学的不好那就可能是身死国灭，搞不好还要遗臭万年。 君主论是马基雅维利于1513年左右撰写的一部政治理论著作。主要探讨了君主如何获得权力、巩固权力以及维持国家稳定。就像孙子兵法为战争而生，我们也可以通过这本书来理解领导力和管理的艺术。 领导力的关键 要提升领导力，就必须要知道，在那个位置上，最核心和关键的力量是什么。 马基雅维利就很清晰的点出了，君主要为他的权力奠定坚实的基础，否则就必然会招致灭亡。那么同样，你要领导别人，就必须掌握构成你权力来源的基础。如果一个技术研发团队负责人对于技术一窍不通，不能很好的解决问题，那么他肯定是领导不下去整个团队的。 南唐后主李煜，吟诗作画一把好手，“春花秋月何时了，往事知多少”更是流传千古，但是身为君主，生长于深宫妇人之手，对于军事战略一概不知，北宋一打过来便兵败如山倒，献国投降，最终备受凌辱，只能哀叹“几曾识干戈”。 所以第一个关键就是理解领导人位置的职责。如果需要你去在那个位置，你能做到解决什么关键问题，解决的好，解决的妙，能够让你不被替换，那么这就是构成你权力来源的基石。 明智的人总是秉持这样的信念：“最不可靠又最不堪一击的莫过于没有实力做后盾而徒拥虚名或虚张声势。” 不当滥好人 每个君主都希望臣民赞美他的宽仁，不会希望说他残酷。领导也是如此，希望别人赞美他的宽厚，不希望别人说他的无情严苛。 为了研究事情应当怎么做而无视事情实际上怎么做，这样的人救不了自己，只会自取灭亡。凡事标榜仁义道德的人，一旦置身鸡鸣狗盗之徒当中，到头来一定惹祸上身。所以说，身为君主如果要存活下去，一定要学会不当滥好人。 身为领导人，只要严苛能够解决问题，维持队伍的团结，那么就不应该介意这个名头。总有队伍里有害群之马，对于这些人，就应该使用雷霆手段，严以待之。如果当个滥好人，和稀泥，不严格指出问题加以要求，那么最后造成团队婚乱和失序，处处漏洞破绽，最后受害的还是自己。 领导不见得一定要具备好的道德特质，非常时期可以采取非常手段，但确实有必要让人家觉得他样样具备这些品质。他一定要有心理准备，准备随时顺应运气的风向和形势的改变。如果可能的话，他不应该忽视德行，但是必要的时候，他应该知道如何为非作歹。 关于人性 身为领导，一定是要钻研，做到人性的通透的。理解人性，才能用人。 刘邦就是任用了汉初三杰，才能打败当时勇猛无双的项羽，建立四百年的大汉帝国，也是因为他通透人性，他知道士人才俊渴望的是裂土封侯，所以他能给韩信萧何这些人封王拜相。天下百姓最渴望的是安居乐业，他能约法三章。刘邦从一介亭长到称汉高祖，没有对于人性的通透理解是做不到的。 马基雅维利对人性的评价并不高，他认为能抢就抢是生而为人的天性。 世人大体而言是忘恩负义、反复无常、喜欢说大话、虚伪成性、避危趋安、贪得无厌。你给了他们好处，他们就心向着你，像我在前面说的，在患难仍然遥远的时候，他们乐意为你赴汤蹈火，财物、性命甚至儿子都可以奉献给你；可是到了紧急关头，他们就会转身而去，连头都不回。 所以，如何利益职责分配是领导者必须学会的技巧，人性其实都是趋利避害的，但是如果领导者能够理解把握这种天性，那么做事情必定是无往而不利。 ","link":"https://thxit.github.io/qrnUt6J7t/"},{"title":"Ubuntu/Debian/CentOS搭建Socks5代理一键脚本","content":"Socks5属于明文代理，不要用于科学上网，否则会被阻断端口，可用于正常的跳板使用； 比如SSH转发加速国外VPS的连接速度，特别是一些延迟高或者丢包高的VPS； 使用Socks5转发后SSH就可以快速稳定的连接了，解决高丢包SSH断开的问题； 支持系统 Debian7+ Ubuntu14.04+ CentOS6+ 安装 下载脚本 wget --no-check-certificate https://raw.github.com/Lozy/danted/master/install.sh -O install.sh 安装脚本 bash install.sh --port=端口 --user=用户名 --passwd=密码 其中的端口 用户名 密码自行修改后粘贴到SSH里运行安装即可； 完成后会提示Dante Server Install Successfuly即表示安装成功； 安装后如果连接不上，检查设置的端口是否已经放行； 说明：安装完成后会显示内网IP地址，但在实际使用的时候需要用外网IP地址； 使用 一般使用IP和用户名密码即可使用 如果需要固定IP或IP段，可以修改配置文件设置白名单 vi /etc/danted/sockd.conf 修改以下代码，改成你需要设置的白名单IP或IP段即可，然后重启使其生效； client pass { from: 0.0.0.0/0 to: 0.0.0.0/0 } 卸载 bash install.sh --uninstall 命令 service sockd start /etc/init.d/sockd start 启动socks5服务器守护进程 service sockd stop /etc/init.d/sockd stop 停止socks5服务器守护进程 service sockd restart /etc/init.d/sockd restart 重新启动socks5服务器守护进程 service sockd reload /etc/init.d/sockd reload 重新加载socks5服务器守护进程 service sockd status / 系统进程状态 service sockd state /etc/init.d/sockd state 运行状态 service sockd tail /etc/init.d/sockd tail sock 日志 service sockd adduser /etc/init.d/sockd adduser 添加pam-auth用户：service sockd adduser NAME PASSWORD service sockd deluser /etc/init.d/sockd deluser 删除pam-auth用户：service sockd deluser NAME ","link":"https://thxit.github.io/XRNuqYOYO/"},{"title":"《人民日报》：黑夜固然深邃寒冷，但前行的道路上总有曙光等待着我们","content":"很喜欢人民日报的一句话，黑夜固然深邃寒冷，但前行的道路上总有曙光等待着我们。 在每个人的人生旅途中，总会遇到各种各样的挑战和困难。黑夜，象征着那些让我们感到孤独、无助和迷茫的时刻。然而，正如黎明前的黑暗最深沉一样，在我们前行的道路上，总有曙光在等待，带给我们希望和力量。 无论是工作上的挫折，还是生活中的困境，都会让我们感到前途渺茫，仿佛一切努力都变得毫无意义。人心的冷漠，更是让我们感到心灵的冰冷和无助。那些曾经温暖的记忆，仿佛在黑夜中变得遥不可及。深邃而寒冷的无助感，仿佛要吞噬一切光明和温暖。在黑夜里，我们常常会感到孤独甚至是泪流满面，仿佛整个世界都在与我们为敌。 然而，正是在这样的困境中，我们才能真正认识到自己的内心，发现那些隐藏在心底的恐惧和不安。困境，给了我们一个机会，让我们重新审视自己，找到前行的力量。无论是悲伤、愤怒还是恐惧，这些情绪都是我们内心的一部分。只有学会接受和面对这些情绪，我们才能真正找到内心的平衡和宁静。 人生的道路上，困难和挑战是不可避免的，但正是这些困难和挑战，才让我们变得更加坚强和勇敢。黑夜虽然深邃寒冷，但每一个黑夜的尽头，总有曙光在等待。曙光，象征着希望和新的开始。 曙光的到来，往往是悄无声息的。在我们最无助和绝望的时刻，曙光可能会突然出现，带给我们意想不到的惊喜和温暖。它可能是一句温暖的话语，一次意外的机会，或者是一个新的想法和灵感。曙光的到来，让我们重新燃起对生活的希望和热情。 当曙光终于到来时，我们会发现，所有的努力和坚持都是值得的。曙光的到来，让我们感受到内心的温暖和喜悦。它带给我们新的希望和力量，让我们重新燃起对生活的热情。 我们都要相信，前方总有希望和光明。通过坚持不懈地努力和不断学习成长，我们可以在黑夜中找到曙光，迎接新的开始。 愿每一个在黑夜中奋力前行的你，都能找到内心的力量和希望，迎接属于自己的曙光。 ","link":"https://thxit.github.io/kiq4yJmXv/"},{"title":"郭有才的爆火，折射的是小镇做题家的悲哀","content":"又到了一年一度的高考季，菏泽，这座山东小城却显得热闹纷呈。当高考学子们在菏泽南站附近的考场奋笔疾书，千军万马过独木桥之际，各路直播“大咖”也纷纷汇聚至此，盼望着能成为郭有才一样越过抖音流量龙门的幸运儿。 郭有才的故事不必多说，一袭皮衣，溜光的大背头，80年代的复古滤镜，一首所谓“伤感回味”的《诺言》，让他在抖音爆红，一周时间涨粉千万，顺势带火了菏泽南站。几近是一瞬间，名利加身，随后更多的背后细节挖出。母亲去世，烧烤摆摊，贤妻不弃，岳母相助，而后就是翻身逆袭，“贤妻扶我凌云志，我赠贤妻万两金”。 现实往往有点讽刺，有了万两金，那志便是凌云志，无怪乎各路人马纷纷立志扎根菏泽南站。 这不得不让人想到那些曾经天真烂漫的小镇做题家们。 什么是小镇做题家？ “小镇做题家”是近年来在网络上流行的一个词汇，带有一定的讽刺和调侃意味。它通常用来形容那些来自小城镇或农村地区，通过刻苦学习和大量做题，考上重点大学或进入大城市工作的年轻人。 我们知道，教育资源在城乡之间存在显著差距。大城市拥有更多的优质教育资源，包括优秀的师资力量、丰富的课外活动和先进的教学设施。而在小城镇和农村地区，教育资源相对匮乏，学生们只能通过大量做题来提高成绩，以弥补资源的不足。 “小镇做题家”背后往往有着家庭的巨大期望。父母希望通过孩子的努力，改变家庭的经济状况和社会地位。这种期望和压力让这些学生在学业上更加拼命，但也可能带来心理上的负担和焦虑。 “小镇做题家”反映社会阶层固化的问题。尽管通过高考进入了重点大学，但这些学生在大城市中可能仍然面临诸多挑战，如适应问题、人际交往困难、职业发展瓶颈等。他们的社会地位和经济状况并没有因为考上大学而得到根本改变。 他们或是从贫寒的山村或是泥泞的乡间，通过学习想改变自己的命运，但有舆论把他们批为小镇做题家，嘲讽他们像是脱不下长衫的孔乙己。他们虽无万两金，身怀凌云志，却被时代狠狠嘲弄。 郭有才的火，就是有钱的平台金主们抽在小镇做题家，脱不下长衫的孔乙己们脸上的一记响亮耳光，有人可能会说，路有千万条，郭有才也很努力。我无意评价郭有才个人的道德是非和背后曲折，因为没有郭有才，也会有李有才张有才。万两金的流量红利恰似一根香喷喷的肉骨头，只是刚巧砸中了他。 马克吐温有篇很有名的小说《百万英镑》，主人公亚当斯，一个在伦敦街头流浪的美国人。他原本是一个穷困潦倒的水手，因一次意外漂流到伦敦，身无分文，衣衫褴褛，几乎走投无路。 一天，亨利在街头偶遇了一对富有的兄弟——阿贝尔和戈登·霍普金斯。他们正在进行一场奇特的赌局，赌注是人们对财富的态度。他们决定给亨利一张面值一百万英镑的钞票，并观察他在一个月内如何使用这笔巨款，以及这笔巨款对他生活的影响。 亨利拿到这张钞票后，最初感到非常困惑和不安，因为他没有办法将这张巨款兑换成小额钞票，也无法直接使用它。然而，随着时间的推移，他发现这张百万英镑的钞票竟然给他带来了意想不到的好处。 亨利在伦敦的上流社会中迅速走红。商店老板、饭店经理、酒店经理等纷纷对他毕恭毕敬，愿意为他提供各种商品和服务，甚至不收取任何费用，只为了能够在未来与这位“百万富翁”建立良好的关系。亨利的衣食住行都变得无比奢华，他甚至开始受到社交名流的邀请，参加各种豪华的宴会和聚会。 当然这个故事的结局是圆满的，但是故事里人们对于亨利的态度转变是耐人寻味的。狄更斯在《雾都孤儿》里说，这是最好的时代，这是最坏的时代。现实中的郭有才拿到了百万英镑，理所应当的改变了自己命运，来源或许是张一鸣对于推荐机制的小小更改，抑或是群体意识的发泄。 归根到底，人们只是在追逐崇拜金钱，穷困的小镇做题家也谈不上甚至谈不上寒门贵子，沦为时代的笑话，这是小镇做题家们的悲哀，也是整个社会的悲哀。 ","link":"https://thxit.github.io/e6EwioSMd/"},{"title":"跨越不可能","content":"以前读书总是走马观花，看一遍就完事了，后面才明白，这样的读书，几乎在脑海中留不下太深刻的印象。只阅读不输出，那就是两条腿瘸了一条。 这本《跨越不可能》在成长学习类型中算是条例非常分明的一本，分了四个部分，分别是学习的动机，学习力、创造力和心流。 学习动机里我认为讲的比较好的是对于恐惧情绪的理解，恐惧情绪是驱动我们的行为动机当中的一种，我们应该正确认识然后理解直至面对它。作者讲的很关键的一点是成长性思维，不论是恐惧还是多巴胺内啡肽，都是大脑鼓励驱使我们去做一些事情的手段。我们应当改变自己的思维，放弃那种“我不行”“我做不到”“那不可能”的禁锢性思维，而是去想怎么做，怎么能改变它让它更好，注意力集中在事情而不应该沉溺于如自己的恐惧情绪当中不能自拔。作者也讲了如何设立目标，如何认识大脑的认知模式。 学习力则是主要通过阅读和获取新的知识技能。作者提出了怎么切入新的领域并且明白自己已经搞懂了。主要方法就是分梯次难度阅读相关专业领域的五本书，然后带着问题去询问专家。当需要学习新技能是，主要就是对于新技能的流程进行拆解，寻找流程中的关键环节和各个部分的共性，根据二八法则进行切入。训练情商则是在讲述了什么是情商后，给出了两点建议，一个是谈话途中停顿和深呼吸自我询问以控制自我和他人情绪，而是练习倾听和同理心，感知他人情绪。 随后又论述了创造力的机制以及如何提升创造力，尝试发散思维，每天保持好心情，使用潜意识解决问题都是提升自己创造力的方法。最终作者想要让我们达到的目标就是“心流”状态，不再赘述。 ","link":"https://thxit.github.io/yKcEvRBqy/"},{"title":"《反本能：如何对抗你的习以为常》","content":"这本书的主题是反本能，我们就应该了解什么是本能。 什么是本能呢？作者用了动物性的说法，动物很少做那种短期内看不到收益的事情，因为动物的本能就是及时的享乐，进食和交配。人类作为更为高级的生物，则学会了为了更为长远的利益而克制自己享乐的本能。然而人终究是一种矛盾体，世界变化的太快，而身上的兽性基因并没有完全跟上文明的步伐，导致我们仍然会有一些动物性的缺陷和残余，影响着人的方方面面，如果能克服这种缺陷，人将朝着更高的境界去进化，反之则退化成为动物无异。 如何克服这种享乐的本能是我们的课题，而这种享乐的本能最为集中爆发的点就在于拖延。我们的大脑明明知道事情很重要，我们需要去做，却一再的拖延，转而沉迷于各种诱惑性的事物，比如游戏短视频。那么我们就应该分析拖延的成因，我们之所以拖延，就是源于大脑的自我保护机制，人类如果一直工作，我们的身心也会疲惫生病从而摧毁个体，那么我们的大脑就会以各种形式提醒我们，告诉我们累了需要去休息。大脑最常见的保护机制就是睡眠、遗忘、逃避和不适应反馈。 进化的原则就是这样，生存是生命的第一要务，我们的大脑时刻提醒着，只要某些事情对于生存有所威胁，那么它就会做出强烈反应。比如我们工作或者做一些高负荷高耗能的事情，那么大脑就会倾向于将它们定义为危险事物，触发我们的自我保护机制然后逃避瞌睡。 那么我们是如何坚持的，就是看我们用理性的认知去对抗大脑的感性认识。用理性告诉我们，我们是否应该做，应该坚持。另一方面，我们也容易被一些成瘾性的事物所吸引，我们之所以会上瘾，就是在漫长的进化过程中，我们的大脑潜意识已经习惯性的认为，能够让我们产生愉悦感的事情会有保护和传承基因的作用。比如我们爱看美女，爱吃东西，满足了我们对于性和食欲的愉悦需求。我们刷短视频，则是我们对于远古信息匮乏的恐惧，本质都是生存下的保护机制，但是这些在现代社会却成为成瘾的诱因。 那么，我们怎么抗拒并且扭转这种拖延的习惯呢？最简单好用的方法就是从简单开始。大脑对于高耗能的任务都有排斥感。如果我们降低了能耗门槛，通过先做简单的任务获得激励，让我们意识到我们已经启动已经在做了，万事开头难，如果开头都被我们做好了，那么再逐渐坚持下去就显得不那么困难。 设定目标时要明确，最好是有期限可量化，因为人类对于不确定的恐惧是天生，就像我们看到进度条未知会烦躁一样，如果我们不能获得对于我们自身任务达成的反馈，那么我们就会很容易放弃，所以目标是一定要明确有期限的，最好带上奖惩机制。另外，增加睡眠时间和质量、改善周围环境也是不错的办法。我们也可以通过抬高享乐成本来控制自己，比如把那些享受性质的游戏或者app删除，增加下载或者进入成本。 那么我们经常做计划，却又总是计划失败的原因又是什么呢？作者的观点是我们在做计划时，往往过于乐观，低估计划完成的时间，并且高估计划完成的情况。我们总是把计划排的满满当当，但是如果完成不了的项目太多么，我们又会自然而然的产生一种完成不了又怎么样的想法，从而引发破窗效应么，完成不了的计划就越来越多。要解决这个问题，最好是从实际出发，并且给自己预留一定的机动时间。 书中还讨论了学习的路径依赖的问题。就是我们在工作或者学习的时候，往往会采用我们最熟悉的方式去做事情，将注意力完全放在了目标的实现上。这个很多时候我们不能说它错，但是有一个重要的缺陷，就是会让我们的“经历”变窄。当我们把注意力放在某个特定的范围时，就会自发的忽视和屏蔽与我们目标不相关的信息，从而被单一维度的信息所拘束。如果我们固定了自己的角色，长期以单一角色，使用单一工具单一路径去处理和解决问题，那么我们的观点将会非常单调。所以我们在目标设定时也应该摆脱做题家思维，多考虑路径多样性的问题。 书中的中后部分花了大段讲了记忆和社交情感方面的问题，和其他书的观点比较相似，不再再次赘述。 文末提出了一个表达逻辑，咨询公司发现，最行之有效的方法就是在收集信息前对信息进行结构性分析，流程是：提出假设，设计流程，沙盘推演，分类处理，得出结论，最终得出相应的对策。也就是说，我们在整理自己的思路，构思解决问题的内容时，先不要急着去搜集信息，而是先对问题做假设，通过假设去寻求有用的信息，降低信息的收集成本。 我觉得文末的几段写的很好，就在此引用吧： 人生所谓的意义，是我们赋予自己行为的一种支撑。它是我们价值观的产物，而不是生命本来就具有的。意义的产生来源于我们对事物的认知及其关联的构。人一直都是害怕不确定性的动物，就像我们的祖先看到草丛在动，无法判断是否有狮子就会不安，我们也害怕自己行为的不确定性，如果我们的行为没有一个指定的程序或目标，我们也会产生非常强烈的不适应感。 如果没有及时寻找到新的支撑，也就是赋予新事物一个不一般的意义，那么我们很可能就会陷入质疑——我做这些有什么意义呢？而在这种情况下，我们往往会选择最省劲的行为模式——打游戏，看小说，睡懒觉等。 我也很喜欢英国浪漫诗人威廉·布莱克（William Black）的一句话：“辛勤的蜜蜂，永远没有时间悲哀。”与其不停地思索人生的意义，不如让自己在体验中获得。让自己忙起来，也是良药。 ","link":"https://thxit.github.io/XOIEIIYXt/"},{"title":"影响力法则：简单到不会失败的非暴力沟通技巧","content":"这是一本外国人写的书，写的非常质朴平实，我只看了一遍，但是里面的观点其实是非常实用的，也是值得后续多读几遍的好书。 在生活中，各种各样的人或事物都争先恐后的想要对我们身心施加影响，很多时候我们被影响却也浑然不知。如果我们想要夺回自己的领导权，我们就得知道他们是如何影响我们的。 作者在书中绕开了意识分析和抗拒心理方面的研究和论述，转而使用一种不可见的操纵杆来控制其他方面，影响人的情感和行为。这种操纵杆我的理解就是言辞和行为。这在两点前提中已经体现，第一点是我们要深入理解沟通中影响他人思想行为的方式。我们的措辞身体语言和想法是可以触发对方的心理机制的。第二点就是我们的影响力应该用在对的地方，那就是尊重他人，尊重他人的利益。 作者提出了所谓的64条影响力技巧，我自己把这些分为了三个大类： 一类是关于我们自己的内心和形象塑造。如书中所说，我们通常会认为活动量少的人社会地位较高，但是作者并没有合适的词汇来表达这样一类人。我的理解是深沉的人，他们的社会地位和他们的价值，都更容易赢得他人的尊重与信任，从而对他人增加影响力。那么我们就应该努力让自己变得冷静谦逊自信，由内而外建设我们的内心，我们首先自己达到高能量状态，而后再将能量以影响力的方式扩散。 第二类是语言，当我们冷静大方且不易受到内心情绪的影响，那么我们需要一定的语言技巧来获得对他人的影响力，当然这个也包括肢体语言。我们可以使用重复的方法，反复重复某个观点，像一句老话，谎言重复一千遍就变成了真的。或者说我们也可以削减提供给对方的可选项目，从而引导对方按照我们的思路走。如果想改变对方的想法，那么分散对方的注意力和不断重复自己的方法是非常有用的，不要给对方过多的表达机会，因为如果对方反复的表达自己的观点，那么这种观点反而会在他的脑海力不断留下深刻印象。这点其实是和费曼学习的宗旨不谋而合的。 在语言方面，作者对于关联词的解释是让我有点醍醐灌顶的，很多时候我们已经形成了习惯性的思路。两者没有因果关系的语句，我们使用了带有因果关系的关联词，我们就会第一时间的认为他们两者具有因果关系。很多的论据就是这样设置了一个语言陷阱，但是我们可以利用这个语言陷阱增加我们观点的说服力和影响力。 第三类就是寻求情绪方面的共鸣，人都是喜欢和自己观点一致生活习性相似的人，就像物以类聚人以群分，当我们对他人表达赞美，或者是多用我们，这些都能让对方感到情绪上的舒适。在带有指责性大的场合时，我们应该以中立的语言多提自己少提“你”，而不是指责对方的智商道德能力或者是人品。这样我们更能够赢得对方的青睐。 总儿言之，这本书是本好书，改天再翻读一下。 ","link":"https://thxit.github.io/cAt8jghzW/"},{"title":"输出式阅读法","content":"这本书读过来，其实讲述的还是费曼学习法放在阅读上的具体应用。 但是这位作者和其他作者不一样的是，他强调了兴趣的重要性，而且这是阅读的前提，读自己喜欢的书，按自己喜欢的方式去阅读，获得其中的快乐，才是最大的前提。 作者的观点是费曼式的，阅读最重要的是能够把书中有价值的东西以说和写的形式表达出来。作者的说法是”花十分钟读完一本书，再用三十分钟进行输出，是大量阅读、快速成长的基础“。 然后围绕着输出进行阐述，输出是验证阅读是否有效的重要手段。能够输出的前提和基础是理解能力。输出就是“发送信息”和“采取行动”。 我们阅读首先是应该选择合适的书，有价值的书，不然很容易浪费时间。然后读的时候，根据二八法则进行快速略读，用三分之一理解全部的意思，其实就是抓取重点，同时注意不要心中默读以提升阅读速度。 作者还根艾宾浩斯遗忘曲线提出了一个方法，就是每次看书，从上一次停止阅读的前一章读起，这样能够有效复习之前读过的内容。 还有个要点就是站在作者的角度进行阅读，理解作者的表达欲望，同时带着目的去探索书中的内容。还可以为读书增添一些仪式感，选择合适的时间段进行阅读以提升效率。 ","link":"https://thxit.github.io/iOYQkO59y/"},{"title":"《中国的当下与未来》","content":"郑永年的这本中国的当下与未来，读懂我们的现实处境与30年大趋势，本来以为这本书和那类指点江山的地摊文差不多。越读越觉得并非如此，而是真正值得一读的好书。 想要理解中国的改革，就应该了解中国的架构。和西方的三权分立不同，中国的权力都归于党权，政党治国这也是近代以来经过无数困苦的斗争遴选出来的适合中国的政治理念。文化大革命之后，中国的党政军其实是有一段时间是分立的，但是发现这样有很多弊端，并且在八十年代经济改革受挫之后，引发了巨大的政治风波，随后将党政军合一，并延续了很长一段时间，为十八大之后的集权打下基础。 党权之中，也存在着三权分置的情况，即决策权、执行权和监察权。这是改革所面临的困难和挑战的制度根源之所在。中国是一个大政府，决定资源分配的并不是市场，而是权力。商业群体只能依附讨好权力，给权力寻租一个合适的渠道。 中国的经济体制也分为三层，一层是以央企和大型国有企业为代表的国有资本企业，一层是底层的中小微型企业，一层是介于两者间与两层关联都比较深的企业。 本书的讨论就是两条线并行，一条就是政治方面的分析，主要是对党政改革，中央与地方关系以及政商关系这三个，另一条则是经济方面，经济体制改革和企业家特征这两个方面。 中国政治层面的改革首先是源于党的自我定性，西方幻想通过市场经济引发政治民主化的情况并没有发生，政治家集团是党对于自身的认同，通过考试制度吸纳各阶层的精英人士进入这个权力集团来治理整个国家，其实奉行的是精英治国的理念。反腐败最核心的是什么呢？是清除这个政治家集团中的团团伙伙，避免陷入寡头政治的漩涡。可惜没有进行大规模的法制建设，很容易陷入运动式治理的怪圈。 中国应该理清的是在新时代下的政商关系。过去虽然官员进行权力寻租，商人进行套利，但是客观上发展了经济。当反腐败清除某个官员扫清权力寻租的灰色空间，与此同时相应的商业关系依赖也会被摧毁。过去的关系是官员与商人的私人关系，而不是商人与部门的关系。这也造就了中国商人媚权，短时，只顾赚钱赚快钱的特征。那么作者给出的方案是什么呢？法治建设，将商人与官员的关系和沟通转变为和部门的沟通，促进商业活动的进行，保障商人的人身财产安全。 作者其实说的很多，我也无法一一列举，但是有一个观点令我深以为然。西方是以危机感驱动的社会，总是会刻意夸大渲染对手的威胁，强调自身可能受到的危险和迫害，哪怕暂时没有受到这种迫害。中国是以危机驱动的社会，寻求生活秩序的平静与安稳，不管是政治还是经济，知道被外来的危机所打破。 其背后体现的是哲学的不同，中国的哲学是在各种深刻危机下产生的哲学，其主体思想便是求生存，可以说是“生存哲学”，人是一种工具手段或者是客体，西方则不同，西方哲学的主体是征服，人是主体，是万物的尺度，是一种征服哲学。 贴上作者所说，一句话，中国哲学从来没有超出求生存的水平；即使生存问题没有了，中国人也没有征服世界的念头，而转向了实在的生活。这种哲学的优势就是其和平性质。西方人不相信中国是和平的，这主要是因为西方人以自己的逻辑来理解中国。不过，对中国来说，如果生存哲学不变，其结果也是显然的，那就是继续缺少原创性技术，继续没有能力制定规则，继续当一个善于适应环境的好学生。如果生存哲学仅仅只是人们的一种选择（在汉朝，这仅仅是选择），那么人们还可以做不同的选择；但如果生存哲学已经演变成为“基因”或者“血液”，那么人们只能接受命定论了。 ","link":"https://thxit.github.io/j4o-8tFJ7/"},{"title":"量化数据及指标的可视化学习","content":" 前言 自定义matplotlib版股票行情界面 K线视图可视化 pyecharts实现web版股票行情界面 TA-lib技术指标库 前言 自定义matplotlib版股票行情界面 K线视图可视化 首先我们先抓取目标股票数据，之后查看数据的各类信息，我们选用的baostock框架，当然方法不止这一种，但是像datareader已经停用了，而像tushare则是设置了如积分这样的门槛和限制。 抓取数据后，我们开始构造一个图像， pyecharts实现web版股票行情界面 TA-lib技术指标库 ","link":"https://thxit.github.io/8XtkJEys3/"},{"title":"量化交易数据的处理和分析学习","content":" 前言 遍历DataFrame格式股票数据的方法 例程数据的准备 for in 遍历循环方式 iterrows()生成器方式 迭代器和生成器 使用iterrows()实现遍历 apply()循环方式 前言 在了解了量化交易数据的获取方法之后，我们需要的是对量化数据进行一个数据处理和分析，达到我们想要的结果。 遍历DataFrame格式股票数据的方法 股票分析过程中不可避免的要涉及到对dataframe格式数据的遍历查询和处理，最常用的遍历方法是使用for循环执行，当然Numpy的矢量化方法也可以用表达式代替for循环遍历数据。除此之外，还有别的方法能够遍历dataframe格式数据。现在我们通过实现单均线突破策略为例子，学习这几种方法。 例程数据的准备 单均线突破的交易策略是，若昨日收盘价高出过去20日平均价则今天开盘买入股票，若昨天收盘价格低于过去20日平均价，则今天开盘卖出股票，因此需要遍历查询每个交易日收盘价与过去20日平均价的差值，并且标记查询结果以提供交易操作。 首先我们需要获取上证指数交易数据。采用baostock获取股票数据 import baostock as bs lg = bs.login() print('login respond error_code:' + lg.error_code) print('login respond error_msg:' + lg.error_msg) df = bs.query_history_k_data('sh.601398', 'date,code,high,low,open,close,volume', start_date='2018-01-01', end_date='2020-12-31', frequency='d', adjustflag='3').get_data() # get_data将数据转换为dataframe格式 print(df.head(10)) 所得结果如下： login success! login respond error_code:0 login respond error_msg:success date code high low open close volume 0 2018-01-02 sh.601398 6.3900 6.1100 6.1900 6.1800 537466208 1 2018-01-03 sh.601398 6.3200 6.1200 6.1800 6.1600 349361120 2 2018-01-04 sh.601398 6.1800 6.0600 6.1800 6.0700 435136528 3 2018-01-05 sh.601398 6.1100 6.0600 6.0900 6.0800 281784272 4 2018-01-08 sh.601398 6.1000 6.0400 6.0900 6.0700 218487604 5 2018-01-09 sh.601398 6.1100 6.0400 6.0700 6.0900 167185706 6 2018-01-10 sh.601398 6.1900 6.0600 6.0800 6.1600 248738958 7 2018-01-11 sh.601398 6.2400 6.1400 6.1800 6.2100 197047306 8 2018-01-12 sh.601398 6.3000 6.2000 6.2000 6.2500 218851799 9 2018-01-15 sh.601398 6.4800 6.2400 6.2400 6.4300 530209504 我么随后使用df.rolling().mean()方法计算得到M20移动平均线，该方法只需提供收盘价和移动平均时间窗口大小即可， df['Ma20'] = df.Close.rolling(window=20).mean() # 增加20日移动均线 print(df.head()) # 查看前五行 结果如下： login success! login respond error_code:0 login respond error_msg:success Date Code High Low Open Close Volume Ma20 0 2018-01-02 sh.601398 6.3900 6.1100 6.1900 6.1800 537466208 NaN 1 2018-01-03 sh.601398 6.3200 6.1200 6.1800 6.1600 349361120 NaN 2 2018-01-04 sh.601398 6.1800 6.0600 6.1800 6.0700 435136528 NaN 3 2018-01-05 sh.601398 6.1100 6.0600 6.0900 6.0800 281784272 NaN 4 2018-01-08 sh.601398 6.1000 6.0400 6.0900 6.0700 218487604 NaN 查看末端5行，print(df.tail())，结果如下， login success! login respond error_code:0 login respond error_msg:success Date Code High Low Open Close Volume Ma20 725 2020-12-25 sh.601398 4.9700 4.9500 4.9600 4.9700 153283872 5.1200 726 2020-12-28 sh.601398 4.9700 4.9300 4.9600 4.9700 231926812 5.1025 727 2020-12-29 sh.601398 4.9800 4.9500 4.9700 4.9800 254202319 5.0780 728 2020-12-30 sh.601398 4.9800 4.9400 4.9700 4.9600 254078489 5.0535 729 2020-12-31 sh.601398 5.0100 4.9500 4.9500 4.9900 310003984 5.0340 这里我们看到前20日的移动均线是没有显示结果的，事实上，我们只有在第20个交易日时才能得到第1个Ma20移动平均线数值，我们需要处理前19个交易日中Ma20列的NaN值。可以使用DataFrame.dropna()方法删除NaN值，参数axis=0表示删除包含缺失值行，axis=1表示删除包含缺失值列，参数how=any表示只要有一个缺失值就删除该行或列，how=all表示只要当所有值都为缺失值时才删除该行或列。此处选择只要有一个缺失值就删除包含缺失值所在的行。 df.dropna(axis=0, how='any', inplace=True) print(df.head()) 结果如下： login success! login respond error_code:0 login respond error_msg:success Date Code High Low Open Close Volume Ma20 19 2018-01-29 sh.601398 7.6900 7.3600 7.3700 7.4300 369534176 6.6735 20 2018-01-30 sh.601398 7.4200 7.2100 7.4000 7.2800 246540367 6.7285 21 2018-01-31 sh.601398 7.5000 7.2100 7.2800 7.4800 376775936 6.7945 22 2018-02-01 sh.601398 7.7000 7.4200 7.4400 7.6800 456814016 6.8750 23 2018-02-02 sh.601398 7.6700 7.4400 7.6000 7.6000 332259952 6.9510 for in 遍历循环方式 我们使用遍历循环实现单均线突破策略，我们遍历全部交易日的收盘价数值和Ma20数值，将收盘价数值减去Ma20数值，并使用np.sign()取差值符号，当收盘价在Ma20上方时差值为正，收盘价在Ma20下方时差值为负，由负转正对应为买点，由正转负对应卖点。 def forin_looping(df): df['signal'] = 0 for i in np.arange(0, df.shape[0]): df.iloc[i, df.columns.get_loc('signal')] = np.sign(float(df.iloc[i]['Close'])-df.iloc[i]['Ma20']) return df print(forin_looping(df)[0:5]) 得到结果如下： Date Code High Low ... Close Volume Ma20 signal 19 2018-01-29 sh.601398 7.6900 7.3600 ... 7.4300 369534176 6.6735 1 20 2018-01-30 sh.601398 7.4200 7.2100 ... 7.2800 246540367 6.7285 1 21 2018-01-31 sh.601398 7.5000 7.2100 ... 7.4800 376775936 6.7945 1 22 2018-02-01 sh.601398 7.7000 7.4200 ... 7.6800 456814016 6.8750 1 23 2018-02-02 sh.601398 7.6700 7.4400 ... 7.6000 332259952 6.9510 1 注意使用sign函数时参数的数据格式应当统一，不然非常容易报错。 iterrows()生成器方式 另外一种Python中常用的遍历方式为iterrows()生成器方式，其实所谓生成器就是一种特殊的迭代器，内部支持了迭代器协议，Python中提供生成器函数和生成器表达式两种方式实现生成器，每次请求返回一个结果，不需要一次性构建一个结果列表，节省了内存空间。 迭代器和生成器 在for循环中，如 for i in s: print(i) 在上面的循环中，我们不断的将s的值赋给i，然后打印出来，这种只针对s中元素的循环称为对s的迭代，能够迭代的s称为可迭代的。为了实现for循环，Python需要迭代的对象实现迭代协议或序列协议，以获取一个迭代器，下面是迭代协议的实现，我们实现一个预定义方法： __iter__(self): 返回一个迭代器 for在对对象进行迭代时会调用对象的__iter__方法构造一个迭代器，然后对该迭代器进行迭代，迭代过程就是不断调用迭代器的方法获取元素： __next__(self): 返回下一个元素，迭代完成抛出stopIteration异常 在此定义上实现了上述两个方法的对象称为迭代器。 生成器的行为和迭代器非常类似，功能差不多，但是生成器更加优雅，只需要用关键字yield返回，作用于函数上叫生成器函数，函数被调用时会返回一个生成器对象，生成器本质上是迭代器，最大特点就是代码简洁。 def func(): for a in [1,2,3]: yield a cls_g = func() print(isinstance(cls_g, Iterator)) # True print(dir(cls_g)) # 自动具备 __iter__ 和 __next__ 方法 for a in cls_g: print(a) # 输出: 1 2 3 # 一种更简单的写法是用 () cls_g = (i for i in [1,2,3]) yield函数与return函数的差别在于，包含yield的方法一般用于迭代，每次执行时遇到yield就返回yield后的结果，但是内部会保留上次执行的状态，下次继续迭代时，会继续执行yield之后的代码，直到再次遇到yield后返回，这种懒加载模式特别适合解决内存占用大的集合问题。如果我们创建了一个包含1万个元素的列表，如果用list返回不仅占用很大的存储空间，而且如果我们仅仅需要访问前几个元素那么后面大多数元素占用的空间就浪费了。生成器则是在迭代过程中推算出后续元素，而不是一次性全部算出。 使用iterrows()实现遍历 用过iterrows()遍历方法计算股票每个交易日收盘价和Ma20的差值，此处iterrows是对dataframe格式数据行进行迭代的一个生成器，它返回每行的索引和包含行本身的对象，代码如下： def iterrows_loppiter(df): df['signal'] = 0 for index,row in df.iterrows(): df.loc[index,'signal'] = np.sign(float(row['Close'])-row['Ma20']) return df print(iterrows_loppiter(df)[0:5]) login success! login respond error_code:0 login respond error_msg:success Date Code High Low ... Close Volume Ma20 signal 19 2018-01-29 sh.601398 7.6900 7.3600 ... 7.4300 369534176 6.6735 1 20 2018-01-30 sh.601398 7.4200 7.2100 ... 7.2800 246540367 6.7285 1 21 2018-01-31 sh.601398 7.5000 7.2100 ... 7.4800 376775936 6.7945 1 22 2018-02-01 sh.601398 7.7000 7.4200 ... 7.6800 456814016 6.8750 1 23 2018-02-02 sh.601398 7.6700 7.4400 ... 7.6000 332259952 6.9510 1 [5 rows x 9 columns] apply()循环方式 apply()方法可将函数应用于dataframe特定的行与列，函数由lambda方式在代码中内嵌实现，lambda为匿名函数，可以省去定义函数的过程，让代码更加精简。lambda函数的末尾包含了axis参数，用来告知Pandas将函数运用于行axis=1或者是列axis=0。apply()方法循环方式如下： df['signal'] = df.apply(lambda row: np.sign(float(row['Close'])-row['Ma20']), axis=1) print(df.head()) login success! login respond error_code:0 login respond error_msg:success Date Code High Low ... Close Volume Ma20 signal 19 2018-01-29 sh.601398 7.6900 7.3600 ... 7.4300 369534176 6.6735 1.0 20 2018-01-30 sh.601398 7.4200 7.2100 ... 7.2800 246540367 6.7285 1.0 21 2018-01-31 sh.601398 7.5000 7.2100 ... 7.4800 376775936 6.7945 1.0 22 2018-02-01 sh.601398 7.7000 7.4200 ... 7.6800 456814016 6.8750 1.0 23 2018-02-02 sh.601398 7.6700 7.4400 ... 7.6000 332259952 6.9510 1.0 [5 rows x 9 columns] ","link":"https://thxit.github.io/CEKbaCWK3/"},{"title":"一些设想","content":"使用算力来架构政治经济的分析框架 我一直为苏联的败亡感到非常不理解，现在的主流推论都是将其引导为上层建筑的堕落腐化，在我看来颇有点唯心主义和不可知的意味。因为一个世界top2大国，军事强国，没有外敌入侵，没有巨大天灾，反而自身思想形态出了问题而导致国家解体，是在是有点不可理喻。 所以我设想的是，苏联之所以对于经济制度失去了信心，是因为计划经济的算力已经被美国的市场经济的算力级别拉开了巨大的差距，这也与美国半导体行业的大爆发几乎是重合的。 三体之中有个很有意思的设想，徐福用秦军士兵挥动旗子作为信号组成了一台庞大的人肉计算机，其实两国也是这样。人类是需要对价值进行估算的，即使你用权威消灭了价格，但是价值仍然在那里，作为信息它需要被传递被了解。计划经济的优势在于，它的传递成本很低，很大范围很长时间，价格作为价值的代表，保持着相对的稳定，但是反过来，它也粗暴的忽略了自在物物体本身的价值变化，而这种价值变化是需要不停的被计算的。 那么市场经济是什么呢？是尽可能开发信息，动用人脑的算力，对价值进行不停歇的计算，并且在传递过程中的信息差也将会被套利者计算获利。但是优点是它的计算价格是符合价值回归的。 那么市场经济的弊病在哪里？在于信息的不完备，如果每个人拿到的信息是完备的，那么当然可以发挥出这台庞大人肉计算机的算力去计算价值，但是，如果信息如果被扭曲，那么计算的结果也将会是失真的，这也同样会造成灾难。 ","link":"https://thxit.github.io/4SOECLCrS/"},{"title":"量化股票数据获取学习","content":"股票交易数据是我们进行量化研究的基础，不论是分析还是预测都是要以过往数据进行参考或训练。我们期望的是有一个封装的数据集成包供我们使用或分析，避免我们陷入股票数据获取的繁琐细节之中。之前比较热门的是使用爬虫技术爬取股票数据，但是雅虎财经或是新浪财经都提供了免费的金融数据接口。Pandas和Tushare这些第三方库提供了从财经网站获取股票数据的接口，这样我们仅仅调用API接口就可以轻松获取股票数据了。 Pandas获取股票数据 pandas提供了专门处理金融数据的模块，该模块已经从pandas.io迁移至pandas-datareader包，所以在使用之前需要导入pandas-datareader模块， import pandas_datareader.data as web 我们将pandas_datareader.data取名为web，而获取股票数据接口则为web.DataReader()。下面介绍几个关键参数： 第一个参数：指定股票代码，如果是类似于苹果这样的公司代码直接用“AAPL”缩写，如果是国内A股市场的股票代码，则需要在代码末尾加上市场代码，比如上证股票在股票代码后面加上.ss，深圳股票在股票代码后面加上.SZ 第二个参数：指定股票数据的网站，DataReader可从多个金融网站上获取到股票数据，“yahoo”指定从雅虎网站获取数据，“google”则指定从谷歌网站获取数据。 第三四个参数：指定股票数据的起始时间，默认是2010年1月1日至今。 我们使用DataReader()接口指定从雅虎网站获取2017年1月1日至今的上证指数交易数据，并且打印查看前五行和尾部倒数五行的数据： 国内服务已经停止，故弃用。 Tushare获取股票数据 Tushare是个开放免费的数据爬取平台，Pro版经过改进后，不再是直接从互联网抓取，而是通过社区的采集和整理存入数据经过质量控制后提供。首先我们在官网注册后获取token，而且部分接口设置了全权限，需要达到一定积分后才能使用。daily()接口用于获取日常的股票行情，高接口无权限要求。 easyquotation 到处找能够获取股票数据的框架，不想重复造轮子，而datareader不能用，tushare现在已经不免费而是积分来获利，所以用easyquotation。 安装：pip install easyquotation 使用 导入库：import easyquotation 选择行情：quotation = easyquotation.use('sina') # 新浪['sina'] 腾讯 ['tencent'] 获取所有股票行情：quotation.market_snapshot(prefix=True) 获取单只股票行情：quotation.real('162411') 获取多只股票行情：quotation.stocks(['000001', ‘162411’] 同时获取指数和行情：quotation.stocks(['sh000001', 'sz000001'], prefix=True) 更新股票代码：easyquotation.update_stock_code() 选择jsl（集思路）行情：quotation = easyquotation.use('jsl') # ['jsl'] 设置cookie（可选），如果不设置获取相关数据会有限制： quotation.set_cookie('从浏览器获取的集思录 Cookie') 获取分级基金信息 quotation.funda() # 参数可选择利率、折价率、交易量、有无下折、是否永续来过滤 quotation.fundb() # 参数如上 分级基金套利接口： quotation.fundarb(jsl_username, jsl_password, avolume=100, bvolume=100, ptype='price') 指数etf查询接口-集思路源网页： jsl_username: 集思录用户名 jsl_password: 集思路登录密码 avolume: A成交额，单位百万 bvolume: B成交额，单位百万 ptype: 溢价计算方式，price=现价，buy=买一，sell=卖一 腾讯分时图地址： quotation = easyquotation.use(&quot;timekline&quot;) data = quotation.real(['603828'], prefix=True) 港股日K线图： import easyquotation quotation = easyquotation.use(&quot;daykline&quot;) data = quotation.real(['00001','00700']) print(data) 腾讯港股实时行情： import easyquotation quotation = easyquotation.use(&quot;hkquote&quot;) data = quotation.real(['00001','00700']) print(data) 开发指南 环境初始化，进入项目目录后运行make init 提交代码时通过所以hooks检查即可。 baostock库使用 baostock库是一个无须注册免费开源的证券数据平台，能提供大量准确完整的证券历史行情数据和上市公司财务数据，目前只支持Python3.5以上。 导入baostock库并登陆，再进行接口的配置： import baostock as bs import pandas as pd lg = bs.login() print('login respond error_code:' + lg.error_code) print('login respond error_msg: ' + lg.error_msg) rs = bs.query_history_k_data(&quot;000001.SH&quot;, &quot;date,code,open,high,low,close,preclose,volume,amount,adjustflag,turn,tradestatus,pctChg,peTTM,pbMRQ,psTTM,pcfNcfTTM,isST&quot;, start_date='2010-01-01', end_date='2019-12-31', frequency=&quot;d&quot;, adjustflag=&quot;3&quot;) data_list = [] while (rs.error_code == '0') &amp; rs.next(): data_list.append(rs.get_row_data()) result = pd.DataFrame(data_list, columns=rs.fields) 随后将结果输出并存入CSV result.to_csv(&quot;D:\\\\history_A_stock_k_data.csv&quot;, index=False) ","link":"https://thxit.github.io/0rjqjo4eO/"},{"title":"Matplotlib绘图学习笔记","content":" 前言 函数式绘图 对象式绘图方式 乱码的解决方法 前言 量化交易系统中，我们需要直观的查看数据和评估策略的运行情况，matplotlib则是专业用于绘图的第三方库。 matplotlib主要有两种绘图风格，一种是延续自Matlab的函数式绘图，一种是 Pythton的对象式绘图。 函数式绘图 Matlab中调用函数命令即可轻松绘制图形。Matplotlib受到Matlab的启发而构建，因此也延续了其函数式的绘图方式，设计了一套函数形式的绘图api，调用api即可绘制高质量图形。我们用一个例子来学习。 A股市场经常呈现周期性的涨跌，我们可以使用正弦函数产生绘图的数据，来模拟市场走势。我们可以指定numpy中linspace()函数的开始值、终值和步长来创建一维等差数组，并将该数组作为numpy中sin()函数的x轴数据以生成对应的正弦值，如下： import numpy as np x = np.linspace(0.5, 7.5, 1000) y = np.sin(x) 导入matplotlib库中的pyplot模块，该模块集合了类似matlab的绘图api，如下， pandas.DataFrame.plot、pandas.Series.plot、seaborn的画图功能也是基于pyplot模块构建而成的。 import matplotlib.pyplot as plt matplotlib中figure()函数创建图表大小并设置大小，如下所示。figsize参数指定图像的长和宽。 plt.figure(figsize=(12,8)) matplotlib中的plot()函数用于绘制线条图形，以展现数据的变化趋势。其中linestyle参数设定线条类型，color参数指定线条颜色，linewidth参数设定线条的宽度，label参数设置线条的标签。如下： # lw: line width,用于设置线条宽度 # '--g': 结合linestyle和color，线条使用虚线，颜色使用绿色 # label: 设置线条标签为'sin(x)' plt.plot(x, y, '--g', lw =2, label='sin(x)') matplotlib中xlim(min,max)函数和ylim(min,max)函数分别设置x坐标轴和y坐标轴的数值显示刻度范围， # 调整坐标轴范围 plt.xlim(0, 10) plt.ylim(-1.5, 1.5) matplotlib中的xlabel()函数和ylabel()函数添加x轴和y轴的显示标签，如下， # 设置坐标轴标签 plt.xlabel('X axis') plt.ylabel('Y axis') matplotlib中的xticks(location,labels)函数和yticks(location,labels)函数分别设定x轴和y轴的坐标标签。location为浮点数或整数组成的列表，表示坐标轴上坐标的位置。 labels是location等长的字符串列表，表示坐标的显示标签。rotation参数可旋转调节坐标标签，当坐标密集时可避免标签重叠。如下： # 设置轴标签 plt.xticks(np.arange(0, 10, 2), ['2022-03-06', '2022-04-06', '2022-04-06', '2022-04-06', '2022-04-06'], rotation=45) plt.yticks(np.arange(-1, 1.5, 1), [u&quot;最小值&quot;, u'零值', u'最大值']) matplotlib中的grid()函数用于设置图形中的网格线。其中linestyle用于设置网格的线条类型，color用于设置网格的线条颜色。如下 # 设置网格线 plt.grid(True, ls=':', color='r', alpha=0.5) title()函数设置图形的标题， # 设置标题 plt.title(u&quot;Functional Programming&quot;) matplotlib中的legend()函数增加图例显示，当多条曲线显示在同一张图时，便于识别不同的曲线，使用loc参数可以控制图例的放置位置，upper left(左上角)、upper center(中上)、upper right(右上角)、lower left(左下角)、lower center(中下)、lower right（右下）。如下， # 添加图例 plt.legend(loc='upper right') matplotlib中的annotate()函数可在图形中添加指向性注释文本，我们不妨在最低点(π*3/2, -1)位置用一个红色箭头指向一个买信号，在最高点位置使用一个绿色箭头指向一个卖信号，以此来熟练这个函数的使用。在使用annotate()函数时，要考虑两个坐标点，分别为xy(x,y)指示点坐标，即注释 箭头指向的点坐标，以及xytext(x,y)插入注释文本的点坐标。另外arrowprops参数是以字典格式设置箭头属性(arrow propertiose)。如下， # 添加sin(x)的最高点注释 plt.annotate('max sell', xy=(np.pi/2, 1), # 箭头指向点的坐标 xytext=(np.pi/2, 1.3), # 注释文本左端的坐标 weight='regular', # 注释文本的字体粗细风格 color='g', # 注释文本的颜色 fontsize=15, # 注释文本的字体大小 arrowprops={ 'arrowstyle': '-&gt;', # 箭头类型 'connectionstyle': 'arc3', # 连接类型 'color': 'g' # 箭头颜色 }) plt.annotate('min buy', xy=(np.pi*3/2, -1), xytext=(np.pi*3/2, -1.3), weight='regular', color='r', fontsize=15, arrowprops={ 'arrowstyle': '-&gt;', 'connectionstyle': 'arc3', 'color': 'r' }) 显示图形， plt.show() 完整代码如下： import numpy as np import matplotlib.pyplot as plt x = np.linspace(0.5, 7.5, 1000) y = np.sin(x) plt.figure(figsize=(12, 8)) # 创建图形并且设置大小 # 创建函数sin(x)图 plt.plot(x, y, '--g', lw=2, label='sin(x)') # 调整坐标轴范围 plt.xlim(0, 10) plt.ylim(-1.5, 1.5) # 设置坐标轴标签 plt.xlabel('X axis') plt.ylabel('Y axis') # 设置轴标签 plt.xticks(np.arange(0, 10, 2), ['2022-03-06', '2022-04-06', '2022-04-06', '2022-04-06', '2022-04-06'], rotation=45) plt.yticks(np.arange(-1, 1.5, 1), [u&quot;最小值&quot;, u'零值', u'最大值']) # 设置网格线 plt.grid(True, ls=':', color='r', alpha=0.5) # 设置标题 plt.title(u&quot;Functional Programming&quot;) # 添加图例 plt.legend(loc='upper right') # 添加sin(x)的最高点注释 plt.annotate('max sell', xy=(np.pi/2, 1), # 箭头指向点的坐标 xytext=(np.pi/2, 1.3), # 注释文本左端的坐标 weight='regular', # 注释文本的字体粗细风格 color='g', # 注释文本的颜色 fontsize=15, # 注释文本的字体大小 arrowprops={ 'arrowstyle': '-&gt;', # 箭头类型 'connectionstyle': 'arc3', # 连接类型 'color': 'g' # 箭头颜色 }) plt.annotate('min buy', xy=(np.pi*3/2, -1), xytext=(np.pi*3/2, -1.3), weight='regular', color='r', fontsize=15, arrowprops={ 'arrowstyle': '-&gt;', 'connectionstyle': 'arc3', 'color': 'r' }) plt.show() 对象式绘图方式 matplotlib库是由一系列的有组织有从属关系的对象构成的，本质上还是以构建对象方式来绘制图像，但是为了让用户方便，将构造的过程封装在函数中，形成了函数式编程方式。由于函数式绘图在原有对象上增加了一层调用接口，不仅降低了效率，而且掩盖了原有的从属关系，无法体现出对象体系中的细节功能。 我们先了解一下对象从属关系，在matplotlib中，整个图像为一个Figure对象，所有元素依附于Figure对象中。在Figure对象中可以包含一个或者多个Axes对象，每个Axes对象各自拥有坐标系统的绘图区域，包含各自的Title、Axis、Label、Tick、Tick Label等对象元素。 对象式绘图与函数式绘图的最大区别在于pyplot模块的figure()函数创建了名为fig的Figure对象，而后在Figure对象中创建一个Axes对象，Axes对象即为一个绘图区域，如下： fig = plt.figure(figsize=(12,8)) ax = fig.add_subplot(111) 接下来在Axes对象中增加坐标轴标签label对象、tick对象、ticklabel对象和标题title对象，以及对坐标轴的取值范围xlim和ylim进行设定等等，与函数式绘图方式大致相同。 ax.set_xlabel('X axis', fontsize=15) ax.set_ylabel('Y axis', fontsize=15) 效果如下： 完整代码： import numpy as np import matplotlib.pyplot as plt # 生成数据 x = np.linspace(0.5, 7.5, 1000) y = np.sin(x) # pyplot模块中的figure()函数创建名为fig的Figure对象 fig = plt.figure(figsize=(12, 8)) # 在Figure对象中创建一个Axes对象，每个Axes对象即为一个绘图区域 ax = fig.add_subplot(111) # sin(x)图 ax.plot(x, y, '--g', lw=2, label='sin(x)') # 调整坐标轴范围 ax.set_xlim(0, 10) ax.set_ylim(-1.5, 1.5) # 设置坐标轴标签 ax.set_xticks(np.arange(0, 10, 2)) ax.set_yticks(np.arange(-1, 1.5, 1)) ax.set_xticklabels(['2022-07-01', '2022-08-02', '2022-09-02', '2022-10-02', '2022-11-02',], rotation=45, fontsize=45) ax.set_yticklabels([u'最小值', u'零值', u'最大值'], fontsize=15) # 设置轴标签 ax.set_xlabel('X axis', fontsize=15) ax.set_ylabel('Y axis', fontsize=15) # 设置网格线 ax.grid(True, ls=':', color='r', alpha=0.5) # 设置标题 ax.set_title(u&quot;Functional Programming&quot;, fontsize=25) # 添加图例 ax.legend(loc='upper right', fontsize=15) # 添加sin(x)的最高点注释 ax.annotate('max sell', xy=(np.pi/2, 1), xytext=(np.pi/2, 1.3), weight='regular', color='g', fontsize=15, arrowprops={ 'arrowstyle': '-&gt;', 'connectionstyle': 'arc3', 'color': 'g' }) ax.annotate('min buy', xy=(np.pi*3/2, -1), xytext=(np.pi*3/2, -1.3), weight='regular', color='r', fontsize=15, arrowprops={ 'arrowstyle': '-&gt;', 'connectionstyle': 'arc3', 'color': 'r' }) plt.show() 乱码的解决方法 在图片显示的过程中，发现标签文字是一堆乱码，搜索了一下，解决方案是 from pylab import mpl mpl.rcParams['font.sans-serif'] = ['Heiti TC'] # 显示黑体中文 mpl.rcParams['axes.unicode_minus'] = False ","link":"https://thxit.github.io/BmGJX0YRN/"},{"title":"Pandas构建DataFrame股票数据","content":"Pandas是Python环境下最有名最专业的数据分析库，如果说NumPy提供了通用的数据处理能力，那么在处理表格时，大多数开发者会使用Pandas作为统计和分析的主要工具。因为Pandas对于数据的处理更为方便快速和简单。 Pandas是围绕着Serises和DataFrame两个核心数据结构展开的，但是在量化交易系统开发中DataFrame数据结构的使用相对来说比Serises更为广泛。 DataFrame数据生成 以随机漫步的方式获得了收盘股价及对应交易日的涨幅后，我们将这些基础数据生成为DataFrame格式的股票数据。 DataFrame是一个表格型的数据结构，既有索引index也有列索引columns，创建DataFrame的基本方法为df = pd.DataFrame(data,index=index,columns)，其中data参数的数据类型可以支持由列表、一维ndarray或Serises组成的字典、字典组成的字典、二维ndarray等。像下图，可以把DataFrame看成是Excel的表格形态： 接下来我们根据创建DataFrame的基本要求将data、index、columns这三个参数准备就绪。关于列索引columns，我们将收盘价定义为“close”，涨跌幅定义为“price range”。行索引index在此处表示为交易日期。Pandas提供了强大的日期数据处理功能，我们使用pandas.data_range()生成DatetimeIndex格式的日期序列，其中参数包括：起始时间start、结束时间end、时期数量peridos、日期间隔频率freq=‘M’月、‘D’天、‘W’周、‘Y’年等等，此处生成从2010-01-01开始的1000个日期的时间序列。 import pandas as pd # 生成时间序列 dd = pd.date_range('2010-01-01',freq='D',periods=1000) print(f'生成日时间序列：\\n{dd}') 生成日时间序列： DatetimeIndex(['2010-01-01', '2010-01-02', '2010-01-03', '2010-01-04', '2010-01-05', '2010-01-06', '2010-01-07', '2010-01-08', '2010-01-09', '2010-01-10', ... '2012-09-17', '2012-09-18', '2012-09-19', '2012-09-20', '2012-09-21', '2012-09-22', '2012-09-23', '2012-09-24', '2012-09-25', '2012-09-26'], dtype='datetime64[ns]', length=1000, freq='D') 我们通过np.random.normal()返回的数据类型为‘numpy.ndarray',属于data参数支持的数据类型，于是我们将data、index、columns三个参数传入创建DataFrame的方法中，就可以生成DataFrame格式的股票交易数据。此处以ndarray组成的字典形式创建DataFrame，字典的每个键所对应的ndarray数组分别成为DataFrame的一列，共享一个index。如下所示： import pandas as pd import numpy as np import random stock_data = np.random.normal(loc=10.0, scale=1.0, size=1000) stock_data =np.around(stock_data, 2) pct_change =np.around((stock_data-np.roll(stock_data,1))/np.roll(stock_data,1),2) pct_change[0] = np.nan # 生成时间序列 dd = pd.date_range('2010-01-01',freq='D',periods=1000) df_stock = pd.DataFrame({'close':stock_data, 'price range':pct_change}, index=dd) print(f'股价交易数据：\\n {df_stock.head()}') 股价交易数据： close price range 2010-01-01 9.81 NaN 2010-01-02 8.74 -0.11 2010-01-03 11.44 0.31 2010-01-04 10.32 -0.10 2010-01-05 10.35 0.00 当我们得到DataFrame格式的股票交易数据之后，就能利用Pandas强大的数据分析功能处理我们的数据。此处我们通过Pandas封装的matplotlib绘图功能，绘制其中50个交易日的收盘曲线，用可视化的方式了解随机漫步的股价走势。 import matplotlib.pyplot as plt df_stock.close[150:200].plot(c='b') plt.legend(['Close'], loc='best') plt.show() 得到的结果如下： ","link":"https://thxit.github.io/Lt9YwNuIt/"},{"title":"Numpy模拟随机漫步理论","content":"什么是Numpy和随机漫步理论 NumPy是Python用于科学计算的基础包。它的主要功能是提供了多维数组对象，多种衍生对象和一个用于数组快速运算的混合程序，包含了数学、逻辑、排序、选择、I/O、离散傅立叶变换、基础线性代数、基础统计操作、随机模拟等等。 随机漫步理论则是投资学上的一个假说，认为股票市场的价格会形成随机漫步模式。其是无法被预测的。 随机漫步下的股价 随机漫步理论认为股票的日常价格变动从根本上无法预知，类似于微观粒子的随机运动。但是我们可以从统计学的角度出发，将股票的不可预知性转变为可预知。从统计学的角度，爱德华索普将股票的价格走势比做一名喝醉酒的醉汉在一个路灯下漫无目的的行走，每一步可能向前也可能向后退，由于醉汉的每一步都是随机的，我们无法预测，但是这名醉汉最终的位置概率是呈现正态分布的，随着出现的位置范围不断变大，距离起始点越远的位置概率越小。 同样，我们无法预测股票价格如何变化，但是我们可以从呈现的正态分布中知道股票变化的概率分布，因此股价的波动性是可以量化的。这也是日后量化金融发展的理论基础。 正态分布 正态分布描述的是某件事出现不同结果的概率分布，而描述一个正态分布曲线，我们只需要两个参数，一个是决定曲线峰值的参数μ，一个是决定曲线陡峭程度的参数σ。当μ=0，σ=1时的正态分布是标准正态分布。 随机序列的生成 我们选取正态随机漫步理论来生成股价以支撑我们后续的学习。Python内置的random模块和第三方库NumPy模块都提供了生成随机漫步序列的方法。 内置random模块的使用 我们使用random模块的normalvariate(mu,sigma)方法来生成符合正态分布的随机数，其中mu对应公式的期望值μ，标准差σ，当μ=0，σ=1时为标准正态分布。 import random print(&quot;normalvariate: &quot;,random.normalvariate(0,1)) normalvariate: 0.6753952361310515 然而这样的方法只能生成一个随机数，所以我们采用循环的方法产生一组随机数列。 a = [] for _ in range(1000): a.append(random.normalvariate(0,1)) 然后使用matplotlib.pyplot.hist()方法将随机数列绘制成直方图 import matplotlib.pyplot as plt plt.hist(a,bins=30) plt.show() 从图中可知直方图呈现两边低，中间高，左右对称的钟形，符合正态分布的标准。 NumPy对于随机数生成的模块运用 NumPy是以N维数组对象ndarray存储数据的，因此np.random.normal()的返回值类型就是numpy.ndarray。 print(type(np.random.normal(loc=0.0, scale=1.0,size=1000))) 相比通过random.normalvariate()方法生成一个等价的Python列表，使用np.random.normal()方法生成1000000个规模的随机数组显得更有效率和优势。 我们可以使用timeit计时模块测量两种方法的代码运行时间。将两种方法封装成函数，以函数形式分别测量两种方法的代码运行时间。 from timeit import timeit import numpy as np import random def list_test(): walk = [] for _ in range(1000000): walk.append(random.normalvariate(0,1)) def ndarray_test(): np.random.normal(loc=0.0,scale=1.0,size=1000000) t1 = timeit('list_test()','from __main__ import list_test',number=1) t2 = timeit('ndarray_test()','from __main__ import ndarray_test',number=1) print(&quot;list:{}&quot;.format(t1)) #list:0.515951042 print(&quot;ndarray:{}&quot;.format(t2)) #ndarray:0.01707875000000003 矢量运算 矢量计算是将函数和运算符应用到数组并且进行计算时，很多函数和运算符都会对数组内元素进行自动计算。这样我们仅仅用简洁的表达式就可以代替Python的for循环，我们使用NumPy的random.normalvariate()生成一个平均收盘价为10元，振幅1元（标准差），样本数量为1000的正态随机分布数组。 stock_data = np.random.normal(loc=10.0,scale=1.0,size=1000) stock_data = np.arround(stock_data, 2) #保留2位小数 print(&quot;stock_data:\\n {}&quot;.format(stock_data)) 尝试一下更复杂的操作，如计算股价的涨跌幅，涨跌幅的计算公式为：（今日收盘价-昨日收盘价）/昨日收盘价*100%。np.roll()为循环右移，此处将今日收盘价数组循环右移一位得到了昨日收盘价数组，那么昨日收盘价数组的第一个值就为无效值，对应计算得到的pct_change的第一个值需要设置为无效值np.nan stock_data = np.random.normal(loc=10.0,scale=1.0,size=1000) pct_change = np.around((stock_data-np.roll(stock_data,1))/np.roll(stock_data,1),2) pct_change[0] = np.nan print(&quot;pct_change:\\n {}&quot;.format(pct_change)) pct_change: [ nan -0.12 -0. -0.03 0.22 -0.14 0.28 -0.2 -0.01 0.02 -0.05 0.05 0.08 -0.04 0.07 -0.07 0.05 0.03 -0. -0.06 -0.1 0.08 0.16 -0.21 0.24 -0.19 -0.11 0.41 -0.2 -0.1 0.22 -0.08 0.16 -0.14 -0.02 0.15 可视化随机漫步轨迹 之前我们模拟过醉汉的移动距离的最终位置的落点分布，现在我们为了表现他的行动轨迹，将醉汉的移动简化为一维的移动，规定他只能在一条直线上随机前进或者后退，我们先使用numpy.random.randint(low,high=None,dtype='l')函数产生随机数。范围区间是最小值low到最大值high，包含low，不包含high，dtypt是数据类型，size是数组维度大小，默认数据类型是np.int，high未填写时，默认生成的随机数是【0，low】。 游走轨迹代码生成如下： draw = np.random.randint(0,2,size=nsteps) steps = np.where(draws &gt; 0,1,-1) walk = steps.cumsum() 使用matplotlib绘图后是这样的： 由于醉汉的每一次都是随机的，我们并不能从如此多的可能性中预测他最终会选择哪一条，但是我们可以以概率来判断他未来的可行方向和趋势。我们合并了1000次的漫步结果，并且将计算过程封装为random_walk(),模拟醉汉从0轴开始1000次随机游走2000步的模拟轨迹: import numpy as np import matplotlib.pyplot as plt from pylab import mpl mpl.rcParams['font.sans-serif'] = ['Heiti TC'] mpl.rcParams['axes.unicode_minus'] = False def random_walk(nsteps = 1000): draws = np.random.randint(0, 2, size=nsteps) print(f'random walk direction is {draws}') steps = np.where(draws &gt; 0, 1, -1) # 将0转换成1 walk = steps.cumsum() # 累加方式记录轨迹 return walk def simplot_random_work(): _ = [plt.plot(np.arange(2000), random_walk(nsteps=2000), c='b', alpha=0.05) for _ in np.arange(0, 1000)] plt.xlabel('游走步数') plt.ylabel('分布轨迹') plt.title(u'随机漫步') plt.show() simplot_random_work() 结果： ","link":"https://thxit.github.io/d46mBAjiX/"},{"title":"量化投资","content":"最近萌生了做量化的念头，一个是自己的工作时间与开盘时间重叠，另一个就是简单直接的，懒。 量化投资 就是通过计算程序去实现自动下单的交易系统。 具体操作 一些常用的股票数据查询函数 get_index_stocks 这个函数可以帮助我们获取某个指数的成分股的名单数据。 stocks_pool = get_index_stocks('000300.xshg') stocks_pool 设置沪深300为股票池子，随后对其进行后续的操作。000300.xshg是沪深300的成分股代码。 get_fundamentals 这个函数一般用来获取基本面财务数据。 fundamentals_df = get_fundamentals(query( valuation.code, valuation.pb_ration, income.total_operating_revenue ).filter( valuation.pb_ration &lt; 2, income.total_operation_revenue &gt; 2e10 ).order_by(valuation.market_cap.desc() # 按市值顺序排列 ).limit(100 ),date='2023-5-5') fundamentals_df 我们经常通过这种方式在股票池中通过市净率或者市盈率去筛选出合适的股票标的。 也能通过绘图实现数据可视化，可以用这样一段函数完成绘图工作，以上文中的total_operationg_revenue字段为例子进行绘图： pb_ration = fundamentals_df['pb_ration'] plt.title('pb_ratio') plt.bar(range(len(pb_ratio)), pb_ratio) plt.show() pe_ratio市盈率获取 代码如下： import matplotlib.pyplot as plt plt.title('pe_ratio') name_list = ['000016', '000300', '000905'] num_list = [27.19, 31.57, 47.15] plt.bar(range(len(num_list)), num_list, fc='r',tick_label = name_list) plt.show() ","link":"https://thxit.github.io/liang-hua-tou-zi/"},{"title":"文明现代化价值投资与中国-李录","content":"看这本书,其实是始于李录此人的传奇人生，作为那个年代学生运动的领头反骨仔，流浪到了美国，却变成了后来名声显赫的投资人，并且以投资实业的方式重新返回那个曾经一度封杀追捕他的国家，相比也会感慨良多，对于自己的人生际遇，对于中国和美国的发展方向想必也会有许多的深入思考。 这本书讨论了他对于文明文化的观点。文明是使用和调度资源和能量并且创造出的成果，是在整个人类群体中具有共性和适用性的，是生存发展所必要的，而文化则是人的生活方式习惯和信仰，生存非必要的。 他引用了莫里斯的手法，将一个文明社会使用能量的能力分为，摄入能量的能力，社会组织能力，信息能量的储存能力，以及军事动员能力。并且以此提出了文明1.0到到文明3.0的概念。他称狩猎文明为文明1.0，农业文明为文明2.0，工业文明是文明3.0。并提出先进文明必将征服落后文明。其实我觉得不是很恰当，先进文明并不一定征服落后文明，而是一定会取代落后文明，因为人类社会需要一直向前发展。 着重分析的农业文明是一种利用光合作用能量，依赖土地光照水热的文明，受制于土地上限，最终都将会落入马尔萨斯陷阱，多余人口将通过暴力途径或者其他非自然灾难消灭。这是农业文明一直无法摆脱的瓶颈。而农业社会为了维护生产力，必然会发展出一套组织和动员的架构，从原始的游猎部落向帝国转变。并以此抵抗其他文明的倾轧。比如农业文明的诞生会受到游牧文明的侵袭和骚扰，而工业文明的诞生之初也很容易被农业文明帝国所摧毁。 农业文明的铁律就是瓶颈，就是马尔萨斯。人类的每一次灾难都带来了一场思想上的革命。科举制则是文明2.0的最伟大的制度创新，并且称之为文明发展第二伟大的制度创新。因为它实现了权力分配的平等。他认为最伟大的制度创新就是在现代科技基础之上的自由市场经济。 文明3.0诞生的根本原因则是大西洋经济的形成，最大特点就是在无政府主义状态下发展出来的自由市场经济。那么李录所认为的自由市场经济是什么形态？他引用的是李嘉图分工和交换能使创造出的价值更高的观点，认为1+1大于2，同一市场中增加的交换的人数越多，市场越大，创造出来的增量就越多。所以自由市场的核心就是规模经济。李录所认为的现代化又是什么？现代化就是市场经济和现代科技结合产生的经济无限累进增长的现象。 他认为2.0文明在往3.0文明发展的过程中，分工和交换程度进一步加深，土地和生产资料集中到了一定程度，民间就会出现动荡和混乱，这时候，强有力的政府为了维持统治秩序就会出面打断这个进程。、 书中是怎么看待中国的未来的呢？文中总结了中国过去发展崛起的原因，一个高效率强有力的行政政府和底层庞大而廉价的劳动力。中国现在处于文明2.5，最终是要朝着文明3。0迈进的，自由市场是以创造性的破坏来达成资源配置的最优，而这与政府的职能相悖。&gt;&gt; 自由竞争的市场里，在没有外力干预下，无数个体受资本利益驱使，甘愿冒风险试错，最终成功者必然是市场最需要的，也必然是对未来社会资源最有效的分配。但如果由政府来做，就好比“巧妇难为无米之炊”，这跟政府的基本职能和特征是相悖的。这段引用了原文，写的非常精彩，与我的想法不谋而合。他认为政府将从过去的主导向辅助转变。我认为现阶段是达不到的。 在此之外，本书还提出第六伦，即在中国传统伦理关系中加入了陌生人之间的兼相爱的伦理观。第六伦的核心就是诚信，减少信任交易的成本。但是这属于道德范畴，真正实行需要法治去规范化。 书中提出文明3.0的铁律就是最大的市场最终会成为唯一的市场，最后得出了一些在我看来的偏颇观点，强调中国弱于美国，应该担起应有的责任，并且对于美国的优势地位进行妥协和退让，这个是让我觉得有点荒唐的。万物都是相对的，美国的优势美国的责任是否达成是否做好李录是没有提及的，他给我的潜台词是，美国科技实力雄厚，是最有希望实现和维持全球大市场，集中世界资源达到文明3.0资源巅峰的国家，所以中国应该为这个趋势让路。 并且李录的自我认同也非常有意思，他流落美国，安稳定居后，接受了美国精英交易，但是中国传统文化教育也挥之不去，令他一度彷徨到底是中国人还是美国人。那么他是如何排解的呢，他自认为既是中国人，也是美国人，1+1大于2，给他带来了全新的体验，令我觉得忍俊不禁。致力于维护全球化，维护美国优先地位，维护华尔街金融阶层利益当然也融入血液之中，后续种种结论也就得以理解。人呐，就是这么的戏剧。 ","link":"https://thxit.github.io/wen-ming-xian-dai-hua-jie-zhi-tou-zi-yu-zhong-guo-li-lu/"},{"title":"关于","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站 👨‍💻 博主是谁 ⛹ 兴趣爱好 📬 联系我呀 ","link":"https://thxit.github.io/about/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://thxit.github.io/hello-gridea/"}]}